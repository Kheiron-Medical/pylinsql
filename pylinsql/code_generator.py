import dataclasses
import datetime
import io
from dataclasses import dataclass
from typing import List

from .async_database import DatabaseClient
from .core import Dataclass


@dataclass
class _RawColumnSchema:
    name: str
    is_optional: int
    data_type: str


def _db_type_to_py_type(db_type: str) -> type:
    "Maps a PostgreSQL type to a Python type."

    if db_type == "character varying" or db_type == "text":
        return str
    elif db_type == "boolean":
        return bool
    elif db_type == "smallint" or db_type == "integer" or db_type == "bigint":
        return int
    elif db_type == "real" or db_type == "double precision":
        return float
    elif db_type == "date":
        return datetime.date
    elif db_type == "time without time zone":
        return datetime.time
    elif db_type == "timestamp without time zone":
        return datetime.datetime
    else:
        raise RuntimeError(f"unrecognized database type: {db_type}")


@dataclass
class ColumnSchema:
    "Metadata associated with a database table column."

    name: str
    is_optional: bool
    data_type: type

    def __init__(self, raw_schema: _RawColumnSchema):
        self.name = raw_schema.name
        self.is_optional = bool(raw_schema.is_optional)
        self.data_type = _db_type_to_py_type(raw_schema.data_type)


@dataclass
class TableSchema:
    "Metadata associated with a database table."

    name: str
    columns: List[ColumnSchema]


@dataclass
class CatalogSchema:
    "Metadata associated with a database (a.k.a. catalog)."

    tables: List[TableSchema]


async def get_table_schema(
    conn: DatabaseClient, db_schema: str, db_table: str
) -> TableSchema:
    "Retrieves metadata for a table in the current catalog."

    query = """
        SELECT
            column_name AS name,
            CASE WHEN is_nullable = 'YES' THEN 1 WHEN is_nullable = 'NO' THEN 0 ELSE NULL END AS is_optional,
            data_type
        FROM
            information_schema.columns
        WHERE
            table_catalog = CURRENT_CATALOG AND table_schema = $1 AND table_name = $2
        ORDER BY
            ordinal_position
    """
    columns = await conn.typed_fetch(_RawColumnSchema, query, db_schema, db_table)
    column_schemas = [ColumnSchema(column) for column in columns]
    return TableSchema(name=db_table, columns=column_schemas)


async def get_catalog_schema(conn: DatabaseClient, db_schema: str) -> CatalogSchema:
    "Retrieves metadata for the current catalog."

    query = """
        SELECT
            table_name
        FROM
            information_schema.tables 
        WHERE
            table_catalog = CURRENT_CATALOG AND table_schema = $1
    """
    tables = await conn.typed_fetch_column(str, query, db_schema)
    table_schemas = [await get_table_schema(conn, db_schema, table) for table in tables]
    return CatalogSchema(tables=table_schemas)


def table_to_dataclass(table: TableSchema) -> Dataclass:
    "Generates a dataclass type corresponding to a table schema."

    fields = [(column.name, column.data_type) for column in table.columns]
    return dataclasses.make_dataclass(table.name, fields)


def catalog_to_dataclasses(catalog: CatalogSchema) -> List[Dataclass]:
    "Generates a list of dataclass types corresponding to a catalog schema."

    return [table_to_dataclass(table) for table in catalog.tables]


def dataclasses_to_code(types: List[Dataclass]) -> str:
    "Generates Python code corresponding to a dataclass type."

    f = io.StringIO()
    print("# This source file has been generated by a tool, do not edit", file=f)
    print("from dataclasses import dataclass", file=f)
    print("from datetime import date, datetime, time", file=f)
    print(file=f)

    for typ in types:
        print(file=f)
        print("@dataclass", file=f)
        print(f"class {typ.__name__}:", file=f)
        for field in dataclasses.fields(typ):
            print(f"    {field.name}: {field.type.__name__}", file=f)
        print(file=f)
    return f.getvalue()
